# Структура хранения данных в реализации VEEPROM

## Целевая платформа

В качестве целевого устройства был выбран микроконтроллер компании STMicroelectronics модели **STM32F103C8T6**. Вся дальнейшая информация о данном устройстве, упомянутая в тексте, бралась из официального DataSheet[1].


## Организация FLASH-памяти

В качестве энергонезависимой памяти в STM32F1** используется FLASH. Его размер разнится между конкретными моделями серии от 64 до 128 КБ, у используемой в данной работе модели он составляет 64 КБ.

### Расчет доступного пространства

Таким образом у пользователя остается под использования в качестве VEEPROM:

**N_VEEPROM = 64 - ⌈I_PROG/1024⌉**

Где:
- **N_VEEPROM** – количество страниц по 1 КБ, которые можно использовать для реализации VEEPROM
- **I_PROG** – количество байт, которое занимает программа пользователя

### Выводы из расчетов:

1. Количество КБ, которые могут быть доступны под VEEPROM, не превышает 64, таким образом под виртуальный адрес достаточно будет выделить всего 2 байта (на самом деле там выйдет еще меньше т.к. половина памяти уйдет на сами адреса, но требование до 1 байта снизить не получиться, если хочется сохранить возможность писать данные в более чем одну страницу).

2. Доступное количество страниц зависит от размера самой программы, который можно узнать только после линковки. Значит пользователю следует указывать размер VEEPROM самостоятельно, отталкиваясь от целей использования.

### Размещение в памяти

По умолчанию линкер для STM32 располагает все необходимые для работы программы данные единым куском в начале FLASH памяти. Следовательно, чтобы избежать пересечения с ними, место под VEEPROM удобно выделять **с конца FLASH памяти**.

## Структура данных

### Базовый блок данных

В STM32F103C8T6 минимальный размер для данных, записываемых во FLASH составляет 2 байта, а это значит, что при уже имеющихся 2 байтах адреса и 1 байте самих данных остается еще 1 байт, который можно использовать для обработки ошибок.

**Принцип приоритета обнаружения ошибок:** При эмуляции EEPROM на FLASH приоритет следует отдать обнаружению ошибки, а не ее исправлению, потому что последствия работы с ложными данными (из-за неверной коррекции) катастрофичны для структуры и целостности системы. Надежное обнаружение сбоя позволяет инициировать контролируемый безопасный отказ, в то время как попытка исправления может привести к необратимому и незаметному разрушению всех данных.

Вследствие чего, последний байт выделяется под **контрольную сумму**.

### Метаданные страницы

Для дальнейшего построения алгоритма выравнивания износа к каждой странице FLASH памяти следует добавить блок метаданных. В данном блоке должна содержаться информация об износе страницы, а также текущее ее состояние.


**Хранение данных износа:** Минимальное заявленное производителем количество перезаписей составляет 10 000 циклов. Беря более чем шестикратный запас устойчивости можем выделить под хранение данных износа 16 бит. Для единообразия обработки и во избежание проблем с выравниванием адресов добьем объем до аналогичных блоку данных 4 байт, т.о. под состояние страницы также будет выделено 2 байта.

### Итоговая структура страницы

Из всего вышеперечисленного получаем следующую структуру: в начале каждой 1 КБ страницы FLASH памяти хранится 4 байта метаданных, оставшиеся 1020 байт заполнены структурами по 4 байта, хранящими в себе 1 байт данных.

**Емкость страницы:** Одна страница FLASH памяти хранит до 255 байт данных VEEPROM.

---

# Алгоритм выравнивания износа и запись данных

## Инициализация

Система не может знать, сколько раз до ее внедрения стиралась та или иная страница FLASH памяти, поэтому при первичной инициализации памяти размечает каждую страницу как пустую и присваивает значение износа 1.

## Состояния страниц

Для описания текущего состояния страницы используются 4 состояния:

- **ACTIVE** – страница является текущим местом записи новых переменных и в ней еще есть свободные блоки
- **CLEARED** – страница пуста и не имеет в себе каких-либо записей  
- **RECEIVING** – страница находится в состоянии приема актуальных данных от ACTIVE страницы
- **FULL** – страница заполнена данными

## Разрешение состояний

При инициализации VEEPROM проходить по всем используемым страницам и считывает их метаданные. Далее идет процесс разрешения состояний согласно Таблице 1.

**Таблица 1. Схема попарного разрешения состояний**

| Страница 1 | Страница 0 | ACTIVE | CLEARED | RECEIVING | FULL |
|------------|------------|--------|---------|-----------|------|
| **ACTIVE** | | Некорректное состояние. Очистить обе страницы, сделать ACTIVE ту, у которой меньше износ | Продолжить проверку | Некорректное состояние. См. Приложение А «Схема решение конфликта ACTIVE-RECEIVING» | Продолжить проверку |
| **CLEARED** | | Продолжить проверку | Некорректное состояние. Cделать ACTIVE ту, у которой меньше износ | См. Приложение А «Схема решение конфликта CLEARED-RECEIVING» | Продолжить проверку. В случае отсутствия ACTIVE сделать ACTIVE страницу с наименьшим износом |
| **RECEIVING** | | Некорректное состояние. См. схема решение конфликта ACTIVE-RECEIVING | См. Приложение А «Схема решение конфликта CLEARED-RECEIVING» | Некорректное состояние. Очистить обе страницы, сделать ACTIVE ту, у которой меньше износ | Продолжить проверку. В случае отсутствия ACTIVE сделать ACTIVE страницу 1 |
| **FULL** | | Продолжить проверку | Продолжить проверку. В случае отсутствия ACTIVE сделать ACTIVE страницу с наименьшим износом | Продолжить проверку. В случае отсутствия ACTIVE сделать ACTIVE страницу 0 | Продолжить проверку |

## Организация буфера

Итогом разрешения состояний является **кольцевой буфер**, заполненный индексами корректных страниц, сортированный по состояниям (ACTIVE, FULL, CLEARED) и износу.

Указатель буфера всегда установлен на индекс элемента, следующий в буфере после текущего ACTIVE. Перед активной страницей идут страницы в состоянии FULL, перед ними пустые страницы, на последнюю из которых и настроен указатель.

## Запись данных

```c
VEEPROM_Result write(uint16_t varId, uint8_t varValue);
```
*Кодовая вставка 1. Сигнатура метода write.*

### Процесс записи:

1. При записи данных пользователь передает в функцию виртуальный адрес в VEEPROM и значение по этому адресу.

2. Если в текущей ACTIVE-странице есть свободные блоки, новая запись производится в нее.

3. После записи проводится проверка по контрольной сумме, результат которой и возвращает функция записи.

### Смена активной страницы:

1. При заполнении ACTIVE-страницы система переводит ее в состояние FULL.

2. Указатель буфера перемещается на следующую CLEARED-страницу, которая становится новой ACTIVE.

### Миграция данных:

Когда все доступные в буфере страницы заполнены начинается процесс миграции данных:

1. При смене активной страницы система начинает процесс переноса актуальных данных.

2. Новая ACTIVE-страница переводится в состояние RECEIVING.

3. Из всех FULL-страниц, начиная с конца, извлекаются неповторяющиеся актуальные данные и последовательно записываются в RECEIVING-страницу.

4. После завершения миграции страница переводится из RECEIVING в ACTIVE.

### Очистка устаревших страниц:

После переноса начинается очистка устаревших страниц:

- Страницы, оставшиеся после миграции без актуальных данных, переводятся в состояние CLEARED
- При этом увеличивается счетчик износа очищенных страниц
- CLEARED-страницы занимают место в буфере после FULL-страниц

---

# Чтение данных

```c
VEEPROM_Result read(uint16_t varId, uint16_t* varValue);
```
*Кодовая вставка 2. Сигнатура метода read.*

## Процесс чтения:

Функция чтения данных принимает на вход виртуальный адрес данных, которые предполагается считать, а также указатель на переменную, в которую эти данные следует записать.

### Алгоритм поиска:

1. Поиск требуемого значения начинается с конца актуальной страницы
2. В случае отсутствия искомого значения в составе актуальной страницы поиск продолжается в ближайшей по буферу FULL-странице
3. Поиск продолжается по всем непустым страницам

### Обработка результатов:

- Если по итогу проверки прохода по всем не пустым страницам значение не было найдено или его контрольная сумма выявила повреждение данных, то функция возвращает код ошибки
- В случае успешного нахождения данных, по предоставленному пользователем указателю записывается найденное значение
